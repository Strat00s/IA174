a.: The attack works by creating same internal state inside MAC_KeeLoq for both messages. We can achieve that by generating some m1 (2+ blocks, 8B+) and get the MAC_KeeLoq of the first block. This is efectively IV/internal state that would be xored with the next m1 block if we were to run the MAC_KeeLoq on the entire m1. And we can do exactly that to create distinc m2, that will generate same internal state (and same MAC). First m2 block = IV/internal state xor second m1 block. rest of m2 is same as m1. Runtime: tens to hundreds of millisecond
b.: Just like in the answer above, the internal state after both messages (from shattered paper) is the same. So adding any (but same) data to both messages will end in the same state too.
c.: I don't know what is the proper attack so I just use multithreaded birthday attack.
d.: For attack on mac, all we need to succed is for the messages to generate same internal state of sha1. Creating then same additional MAC is relatively easy (e.g. bruteforce the keys). Attack on mac` on the other hand much harder. We once again need for both messages to generate the same internal state, but also the concatenation with keys also has to creat the same state. This drastically increases the complexity of key generation and reduces the probability of a collision.