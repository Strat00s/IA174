a.: The attack works by creating same internal state inside MAC_KeeLoq for both messages. We can achieve that by generating some m1 (2+ blocks, 8B+) and get the MAC_KeeLoq of the first block. This is efectively IV/internal state that would be xored with the next m1 block if we were to run the MAC_KeeLoq on the entire m1. And we can do exactly that to create distinc m2, that will generate same internal state (and same MAC). First m2 block = IV/internal state xor second m1 block. rest of m2 is same as m1. Runtime: tens to hundreds of millisecond
b.: Just like in the answer above, the internal state after both messages (from shattered paper) is the same. So adding any (but same) data to both messages will end in the same state too.
c.: I used multithreaded birthday attack. But as we can't import other modules, the multithreaded part is commented out and instead there is a normal function, which should work the same way. I generate some m1 and m2 using 'SHA1_collision()', create some random key and generate MACs for both messages using the same key. I store the MAC and key combination and create new random key. Repeate until some MAC1 or MAC2 is found that is same as MAC2 or MAC1 respectively. It should take about 2^16 MAC_KeeLoq calls.
d.: For attack on 'mac', all we need to succed is for the messages to generate same internal state of sha1. Creating then same additional MAC is relatively easy (e.g. bruteforce the keys). Attack on 'mac`' is on the other hand much harder. We once again need for both messages to generate the same internal state, but also the concatenation with keys also has to creat the same state. This drastically increases the complexity of key generation and reduces the probability of a collision.