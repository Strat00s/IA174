import hashlib
from keeloq import KeeLoq_enc, PKCS7_padding, KEELOQ_BYTE_BLOCK_SIZE
from utils import XOR

def SHA1(msg: bytes) -> bytes:
    """
    Not efficient for very large messages as entire message is loaded to memory - for very long messages (GBs) use update several times to decrease required memory

    :param msg:
    :return: SHA1 hash
    """
    # initialization
    sha1 = hashlib.sha1()
    # intermediate result is computed see https://docs.python.org/3/library/hashlib.html
    # update applied to update(msg1) and then update(msg2) is equivalent to update(msg1 + msg2) i.e. concatenation of messages
    sha1.update(msg)

    # finalization step - hash of msg is computed
    return sha1.digest()

def insecure_HMAC_SHA1(msg: bytes, K: bytes) -> bytes:
    """
    Insecure construction of HMAC (see RFC 2104 https://datatracker.ietf.org/doc/html/rfc2104 for secure one)

    :param msg: arbitrary size
    :param K: arbitrary size
    :return: SHA1 hash (size = 20B = 160 bits) of concatenated msg and K
    """
    return SHA1(msg + K)


def MAC_KeeLoq(msg: bytes, K: bytes, MAC_size: int=4) -> bytes:
    """
    Standard CBC MAC - standardly last block is returned as MAC

    MAC_size (bytes) is here to allow different (to block size) size of MAC
    - last MAC_size bytes of CBC ciphertext will be used as final MAC
    - smaller value MAC_size=3 will be used to test your script (faster MAC collisions!)

    Implementation:

    you can implement KeeLoq_CBC_enc and take last bytes in this function as MAC
    - this is inefficient as entire CBC ciphertext is stored in memory but we are OK with that


    :param msg: the message to be MAC'ed over
    :param K: the K that will be used for the KeeLoq cipher
    :param MAC_size: the size of the final MAC (in bytes)
    :return: MAC of size MAC_size
    """
    #pad the message
    padded  = bytes(msg) + PKCS7_padding(len(msg), KEELOQ_BYTE_BLOCK_SIZE)
    res = bytes()
    ct_block = b'\00\00\00\00'
    blocks = len(padded) // KEELOQ_BYTE_BLOCK_SIZE
    for i in range(0, blocks):
        pt_block = padded[i * KEELOQ_BYTE_BLOCK_SIZE : (i + 1) * KEELOQ_BYTE_BLOCK_SIZE]
        ct_block = KeeLoq_enc(XOR(pt_block, ct_block), K)
        if blocks - i <= MAC_size // KEELOQ_BYTE_BLOCK_SIZE:
            res     += ct_block
    return res
    return KeeLoq_CBC_enc(msg, b'\00\00\00\00', K)[-MAC_size:]

def MAC_combined(msg: bytes, K: bytes, MAC_size=4) -> bytes:
    """
    Combined MAC =  insecure_HMAC_SHA1(msg, MAC_KeeLoq(msg, K)) = SHA1(msg | MAC_KeeLoq(msg, K))

    :param msg: the message to be MAC'ed over
    :param K: the K that will be used for the KeeLoq cipher
    :param MAC_size: the size of the final MAC (in bytes)
    :return:
    """
    keeloq_mac = MAC_KeeLoq(msg=msg, K=K, MAC_size=MAC_size)
    combined_mac = insecure_HMAC_SHA1(msg=msg, K=keeloq_mac)
    return combined_mac


if __name__ == "__main__":

    def test_MAC_KeeLoq():
        """
        Test the `MAC_KeeLoq` implementation against known test vectors (generated by us).
        """
        test_vectors = [
            {
                "message": b'This is a meaningless message',
                "key": b'z\x92\x0f\x1da\xb8#\x16',
                "MAC_size": 4,
                "MAC": b'\\\xe0\x1eQ',
            },
            {
                "message": b'This is a message with a random end c491f89239f40adb3e181e0cb677ca91',
                "key": b'\xc1.A\r\xcf\xed\xb1\x07',
                "MAC_size": 6,
                "MAC": b'\x10\xcc+\x07\xf19',
            },
            {
                "message": b'',
                "key": b'\x84\xc0\xf7\xca\x1dP\x07@',
                "MAC_size": 8,
                "MAC": b'\x99\xe0\x12o',
            }
        ]

        for tv in test_vectors:
            mac = MAC_KeeLoq(tv["message"], tv["key"], tv["MAC_size"])
            assert tv["MAC"] == mac, "Error: the MAC for {tv['message']} did not match"

    test_MAC_KeeLoq()
    # All tests have passed in case that no AssertionError occurs
    print("All tests vectors passed")
